# Deque

В данной задаче вам нужно реализовать аналог std::deque, поддерживающий move-семантику и аллокаторы

## Что нужно реализовать

Необходимо реализовать класс Deque<T, Allocator>, который должен содержать следующие методы:

- Конструкторы
  - Deque() - по умолчанию
  - Deque(const Allocator&)
  - Deque(const Deque&) - копирования
  - Deque(size_t count, const Allocator& alloc = Allocator()) - создает дек на count элементов
  - Deque(size_t count, const T& value, const Allocator& alloc = Allocator()) - создает дек на count элементов и инициализирует все значения с помощью value
  - Deque(Deque&& other)
  - Deque(std::initializer_list\<T\> init, const Allocator& alloc = Allocator())
- Деструктор
- operator=(const Deque& other) - оператор присваивания копированием
- operator=(Deque&& other) - оператор присваивания перемещением
- size_t size() - возвращает текущий размер дека
- bool empty() - возвращает true если дек пустой
- Доступ к элементам (доступы должны работать за гарантированное O(1))
  - operator[] (без проверок выхода за границу)
  - at() - с проверкой. Кидает std::out_of_range
- Методы для изменения (должны работать за амортизированное O(1))
  - push_back
  - emplace_back
  - pop_back (не проверяет)
  - push_front
  - emplace_front
  - pop_front (не проверяет)

Также ваш дек должен поддерживать работу с итераторами. Для этого вам нужно реализовать следующее:

- Внутренний тип iterator (с маленькой буквы). Этот тип должен поддерживать:
  - Инкремент, декремент
  - Сложение с целым числом
  - Вычитание целого числа
  - Сравнения <,>,<=,>=,==,!=
  - Взятие разности от двух итераторов
  - Разыменование (operator*). Возвращает T&
  - operator-> (Возвращает T*)
  - различные using'и: value_type, pointer, iterator_category, reference
- Внутренний тип const_iterator. Отличие от обычного в том, что он не позволяет менять лежащий под ним элемент. Конверсия (неявная в том числе) из неконстантного в константный допустима. Обратно - нет.
- Внутренний тип reverse_iterator (можно пользоваться std::reverse_iterator)
- Методы для доступа к итераторам:
  - begin, cbegin - возвращают итератор (константный итератор) на первый элемент дека
  - end, cend - возвращает итератор (константный итератор) на "элемент следующий за последним"
  - rbegin, rend, crbegin. crend - реверс итераторы на соответствующие элементы
- Метод insert(iterator, const T&) - вставляет элемент по итератору. Все элементы правей сдвигаются на один вправо. Работает за O(n)
- Метод emplace(iterator, T&&)
- Метод erase(iterator) - удаляет элемент по итератору. Все элементы правей сдвигаются на один влево. Работает за O(n)

## Требования к реализации

- const_iterator не должен быть копипастой iterator. Вспомните про шаблонные параметры (bool IsConst)
- Операции push_back, push_front, pop_back, pop_front, emplace_back, emplace_front не должны инвалидировать ссылки и указатели на остальные элементы дека
- Операции pop_back и pop_front не должны инвалидировать итераторы на остальные элементы дека
- Если сам контейнер константный, то методы begin и end должны возвращать константные итераторы
- Разыменование end, cend - UB. Однако декремент от end (cend) должен давать итератор на последний элемент. Вычитание целых чисел от end, cend так же должно давать валидные итераторы на соответствующие элементы дека
- Ваш дек должен давать строгую гарантию безопасности относительно исключений. Это значит, что в случае исключения в конструкторе или операторе присваивания типа T во время выполнения какого-либо метода дека, последний должен вернуться в исходное состояние, которое было до начала выполнения метода, и пробросить исключение наверх в вызывающий код.
- Тип T не обязан иметь конструктора по умолчанию чтобы храниться в вашем деке. При этом конструктор Deque(size_t count) может не компилироваться
- Тип T не обязан иметь конструктор копирования чтобы храниться в вашем деке.
- Разрешено пользоваться стандартными контейнерами std::vector и std::array. Другими стандартными контейнерами пользоваться нельзя.